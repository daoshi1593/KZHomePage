
<!DOCTYPE html>
<html lang="ch-cn">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>cs106b_ALL | daoshi1593</title>
    <meta name="generator" content="Jekyll v3.9.5" />
    <meta property="og:title" content="cs106b_ALL" />
    <meta property="og:locale" content="en_US" />
    <link rel="canonical" href="https://daoshi1593.github.io/md-files/cs106b_ALL.html" />
    <meta property="og:url" content="https://daoshi1593.github.io/md-files/cs106b_ALL.html" />
    <meta property="og:site_name" content="daoshi1593" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="cs106b_ALL" />
    <script type="application/ld+json">
    {"@context":"https://schema.org","@type":"WebPage","headline":"cs106b_ALL","url":"https://daoshi1593.github.io/md-files/cs106b_ALL.html"}</script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_HTMLorMML-full"></script>
    <link rel="stylesheet" href="../static/blog.css">
    <link rel="stylesheet" href="../static/TOC.css">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      <h1><a href="https://daoshi1593.github.io/">daoshi1593</a></h1>
      <div style=" display: flex;">
        <h2><a href="https://daoshi1593.github.io/blog">Blog</a></h2>
        <h2><a href="https://daoshi1593.github.io/cv">CV</a></h2>
      </div>
      <div id="toc">目录</div>
      <div><h1>cs106b 的相关学习</h1>
<p>首先是 cs106b 的构成
cs106b 主要教的是 C++中的 abstractions(我也不知道啥意思),感觉是 ADT 和一些算法(主要是 recruitions)
cs106b 里面有配套的 7 个 assignments 和 30 个 lecs,下面主要对他们进行记录
[TOC]</p>
<h2>第一单元-assignment1(lec1-6)</h2>
<p>主要以体验 c++为主,里面有堆栈溢出的实践编程,可以感受 c++程序在 qt 里的编译,链接情况,和 debug 相关
让人联想起了 cmake,以后也许会学
关于 lecs,主要介绍一些 ADT 包括最基础的变量,list,array 到 strlib 库里的 vector,Set,Queue,Maps</p>
<h2>第二单元-assignment2(lec7-8)</h2>
<p>这里就开始了使用 ADT 的训练,最终目的就是完成最终的 BFS 的编写,利用队列,各种 ADT,完成一个海水漫灌的模型,顺带的也介绍了一些基本知识如 BIG o 表示法和如何优化算法,评估算法优劣</p>
<blockquote>
<p>PROBLEM:Your task in this part of the assignment is to build a tool that models flooding due to sea level rise. To do so, we’re going to model terrains as grids of doubles, where each double represents the altitude of a particular square region on Earth. Higher values indicate higher elevations, while lower values indicate lower elevations. For example, take a look at the three grids to the right. Before moving on, take a minute to think over the following questions, which you don’t need to submit. Which picture represents a small hill? Which one represents a long, sloping incline? Which one represents a lowland area surrounded by levees?
<img src="../graph_bed/flood_example1.png" alt="flood-example1"></p>
</blockquote>
<pre><code class="language-cpp">Grid&lt;bool&gt; floodedRegionsIn(const Grid&lt;double&gt;&amp; terrain,
                            const Vector&lt;GridLocation&gt;&amp; sources,double height)
{
    Grid&lt;bool&gt; AllMap(terrain.numRows(),terrain.numCols(),false);

    Grid&lt;bool&gt; &amp;AllMaps=AllMap;

    Set&lt;GridLocation&gt; late;
    if (sources.isEmpty())
    {
        return AllMaps;
    }
    Queue&lt;GridLocation&gt; AllMatters;

    for (GridLocation i:sources)
    {
        if (terrain[i.row][i.col]&lt;=height)
        {
            AllMaps[i.row][i.col]=true;
            AllMatters.enqueue(i);
            late.add(i);
        }

    }
    //BFS
    //ALlmatters一直变化,直到为空
    while (!AllMatters.isEmpty())
    {
        //随便选一个
        GridLocation cur=AllMatters.dequeue();
        //走两步
        for (int i=cur.col-1;i&lt;=cur.col+1;i+=2)
        {
            //操作
            if (i&lt;0||i&gt;=terrain.numCols())
            {
                continue;
            }
            //符合条件,压栈
            if (terrain[cur.row][i]&lt;=height)
            {
                AllMaps[cur.row][i]=true;
                GridLocation j={cur.row,i};
                if (!late.contains(j))
                {
                    late.add(j);
                    AllMatters.enqueue(j);
                }

            }
        }
        for (int i=cur.row-1;i&lt;=cur.row+1;i+=2)
        {
            if (i&lt;0||i&gt;=terrain.numRows())
            {
                continue;
            }
            if (terrain[i][cur.col]&lt;=height)
            {
                AllMaps[i][cur.col]=true;
                GridLocation j={i,cur.col};
                if (!late.contains(j))
                {
                    late.add(j);
                    AllMatters.enqueue(j);
                }
            }
        }
    }
    return AllMaps;
}
</code></pre>
<h2>第三单元-assignment3,assignment4(lec10-14)</h2>
<p>这里就开始了递归的训练,先讲基本的递归思想,例子,然后 assignment 要求实现 DFS 的一系列递归问题(难)
在编写递归算法的基础上还要求掌握优化方法(记忆),便面不必须的开支
<strong>这里就需要做一个总结了,DFS 和 BFS 的大总结</strong>
<strong>对于 DFS 来说</strong>
框架为</p>
<pre><code class="language-c++">void dfs() //参数用来表示状态
{
    if(到达终点状态)
    {
        ...//根据题意添加
        return;
    }
    if(越界或者是不合法状态)
        return;
    if(特殊状态)//剪枝
        return ;
    for(扩展方式)
    {
        if(扩展方式所达到状态合法)
        {
            修改操作;//根据题意来添加
            标记；
            dfs（）；
            (还原标记)；
            //是否还原标记根据题意
            //如果加上（还原标记）就是 回溯法
        }

    }
}
</code></pre>
<h3>回溯及其优化</h3>
<ul>
<li>探索,取消,体验各种数据结构</li>
<li>keep track of struct</li>
<li>index 给东西编序号然后回溯 1.解决组合问题,给出一个集合的所有子集
2.DFS 迷宫寻路</li>
</ul>
<p><span id="Recurisive_all_matters">Recurisive all matters</span> 1.抓住基本盘</p>
<pre><code class="language-cpp">if (a == number)
{
    do the basic case;
    return {basic};
}
if (b &lt; c)
{
    return somecases;
}

/* decisions */

/* decison 1 under A condition */
do the fuck ;

/* decison 2 under A condition */
do the fuck ;

...

/* decision n */
do the fuck ;

/* UNDO */

undo the fuck ;


return what we want;
</code></pre>
<h3>assignment 3 : 回溯与 debug 技巧</h3>
<ul>
<li>回溯 :constrain sets</li>
</ul>
<h4>关于 DFS 的大讨论:什么时候回溯,什么时候不回溯,函数传参</h4>
<p><strong>matter A:有序组合</strong></p>
<pre><code class="language-cpp">Set&lt;string&gt; allEmphasesOfHelper(Vector&lt;string&gt; decisionmade, Vector&lt;string&gt; decisiontomake){
    Set&lt;string&gt; emphasis;
    if (decisiontomake.isEmpty())
        return emphasis;
    else
        {
        Vector&lt;string&gt; tokencopy = decisiontomake;
        //这个copy的位置决定了每一此函数调用内tokencopy只取决于给函数的decisiontomake
        for(int i = 0; i &lt; tokencopy.size(); i++){

            if(isalpha(decisiontomake[0][0])){
                // include lowercase-version of this word
                decisiontomake.remove(0);
                decisionmade += toLowerCase(tokencopy[i]);
                if(decisiontomake.isEmpty())
                    emphasis.add(Vec2Str(decisionmade) + Vec2Str(decisiontomake));
                emphasis += allEmphasesOfHelper(decisionmade, decisiontomake);

                // include uppercase-version of this word
                decisionmade.remove(decisionmade.size() - 1);
                decisionmade += toUpperCase(tokencopy[i]);
                if(decisiontomake.isEmpty()){
                    emphasis.add(Vec2Str(decisionmade) + Vec2Str(decisiontomake));
                }
                emphasis += allEmphasesOfHelper(decisionmade, decisiontomake);
            }
            else{
                decisiontomake.remove(0);
                decisionmade += tokencopy[i];
                if(decisiontomake.isEmpty())
                    emphasis.add(Vec2Str(decisionmade) + Vec2Str(decisiontomake));}
        }
    }
    return emphasis;
}
</code></pre>
<ul>
<li>给定一串单词输出所有子集(认为大写和小写是两种状态,则与包含,不包含同构),现在这个问题咋解决?要不要回溯?</li>
<li>答:仍然是深度优先搜索,递归基本盘,参数为 decisionToMake,decisionMade;</li>
<li>然而由于要考虑一串情况(且有序),可以直接循环,每个循环里面是这样的一种情况:包括 Cur,或者不包括 Cur;</li>
<li>此情况不用回溯,因为按值传递,每次调用自己的时候是在创造副本,操作副本,在调用结束退回上一级的时候不会影响上一层次的事情,所以是不需要回溯的</li>
<li>But the point is 什么时候需要回溯</li>
<li>答曰:按引用传递和按指针传递时每一次向下会改变参数,且此参数唯一,所以在每一次结束的时候需要回溯,防止这样一种情况:从低层到高层时,高层使用的参数和底层一样,故需要在低层结尾回溯,也就是使参数在这一个调用内不发生改变(按值传递本就是这样的,所以不需要回溯)
<strong>matter B:constrained subsets</strong></li>
<li>在有限制的条件下排列班次,使 x 最大化</li>
</ul>
<pre><code class="language-cpp">Set&lt;Shift&gt; highestValueScheduleFor(const Set&lt;Shift&gt;&amp; shifts, int maxHours) {

    Set&lt;Shift&gt; shiftmade = {};
    Set&lt;Shift&gt; shifttomake = shifts;
    int shiftHours = 0 ;
    cout &lt;&lt; shifttomake &lt;&lt;endl &lt;&lt;&quot;-----------------------------------------&quot;&lt;&lt;endl ;
    return highestValueScheduleForhelper(shiftmade,shifttomake,shiftHours,maxHours);
}
int checkShift (const Shift &amp;Cur,const Set&lt;Shift&gt;&amp; shiftmade)
{
    for (Shift s : shiftmade)
    {
        if (overlapsWith(s,Cur))
        {
            return 1;
        }
    }
    return 0;
}
int cal (const Set&lt;Shift&gt; &amp;shiftmade)
{
    int cal = 0;
    for (const Shift &amp;s : shiftmade)
    {
        cal += valueOf(s);
    }
    return cal;
}

Set&lt;Shift&gt; highestValueScheduleForhelper( Set&lt;Shift&gt;&amp; shiftmade,
                                          Set&lt;Shift&gt;&amp; shifttomake,
                                          int &amp;shiftHours,
                                          int &amp;maxHours){

    if (maxHours &lt; 0)
    {
        error(&quot;fuck&quot;);
    }
    if (maxHours == 0)
    {
        return {};
    }

    //basic cases
    if (shifttomake.isEmpty())
    {
        return shiftmade;
    }

    Set&lt;Shift&gt; UndosetTomake = {};
    Set&lt;Shift&gt; UndosetMade = {};
    int UndoHours = 0;

    Shift Cur = shifttomake.first();

    shifttomake = shifttomake - Cur;
    UndosetTomake = UndosetTomake + Cur ;

    //判断Cur是否是考虑对象
    if (lengthOf(Cur) &lt;= 0){
            error(&quot;fuck&quot;);
    }
    if (checkShift(Cur,shiftmade)||shiftHours + lengthOf(Cur)&gt;maxHours)
    {
            Set&lt;Shift&gt; without = highestValueScheduleForhelper(shiftmade,shifttomake,shiftHours,maxHours);
            shifttomake = shifttomake + UndosetTomake ;
            return without;
        }

    //Undo 的适合也许得恢复所有的改变.把所有抛弃的Cur放在一个集合里(?
    //exclude
    Set&lt;Shift&gt; MaxValueWithout =highestValueScheduleForhelper(shiftmade,
                                                            shifttomake,
                                                            shiftHours,
                                                            maxHours);

    //include
    shiftmade = shiftmade + Cur ;
    shiftHours = shiftHours + lengthOf(Cur);

    //Undo
    UndoHours = UndoHours + lengthOf(Cur);
    UndosetMade = UndosetMade + Cur ;


    Set&lt;Shift&gt; MaxValueWith = highestValueScheduleForhelper(shiftmade,
                                                         shifttomake,
                                                         shiftHours,
                                                         maxHours);
    //Undo

    shiftmade = shiftmade - UndosetMade;
    shifttomake = shifttomake + UndosetTomake ;
    shiftHours = shiftHours - UndoHours;

    //end
    if (cal(MaxValueWith) &gt;= cal(MaxValueWithout))
    {
        return MaxValueWith;
    }
    else {
        return MaxValueWithout;
    }
}
</code></pre>
<ul>
<li>限制条件</li>
<li>单变量最优化</li>
<li>按引用传递:需要回溯(认为回溯与否取决于使用参数生命周期)</li>
<li>基本模板 <a href="#Recurisive_all_matters">Recurisive_all_matters</a></li>
<li>BFS 的本质是穷举</li>
</ul>
<p><strong>matter C:寻找完美匹配</strong></p>
<pre><code class="language-cpp">
bool hasPerfectMatching(const Map&lt;string, Set&lt;string&gt;&gt; &amp;possibleLinks, Set&lt;Pair&gt;&amp; matching) {

    if (possibleLinks.isEmpty())
    {
        return true;
    }
    if (possibleLinks.size()%2 == 1)
    {
        return false;
    }

    string Cur = possibleLinks.firstKey();
    if (possibleLinks.get(Cur).isEmpty())
    {
        return false ;
    }
    for (string CurLink:possibleLinks.get(Cur))
    {
        Map&lt;string, Set&lt;string&gt;&gt; possibleLinksc = possibleLinks;
        /*关键变量在这里,这个case不需要回溯,就是因为这个函数本质上只包括一个循环,每个循环的参数都不是同一个参数,所以完全不需要回溯,只在一个循环内进行修改*/
        Pair chosen(Cur,CurLink);
        matching = matching + chosen;
        Set&lt;string&gt; Curs = possibleLinksc.get(Cur);
        Set&lt;string&gt; CurLinks = possibleLinksc.get(CurLink);
        possibleLinksc.remove(Cur);
        possibleLinksc.remove(CurLink);
        //图里面的crud
        for (string Curt:possibleLinksc.keys())
        {
            if (possibleLinksc.get(Curt).contains(CurLink))
            {
                possibleLinksc.put(Curt,possibleLinksc.get(Curt)-CurLink);
            }
            if (possibleLinksc.get(Curt).contains(Cur))
            {
                possibleLinksc.put(Curt,possibleLinksc.get(Curt)-Cur);
            }
        }
        if (hasPerfectMatching(possibleLinksc,matching))
        {
            return true;
        }
        else{
            matching = matching - chosen;
        }

    }
    return false;
}
</code></pre>
<ul>
<li>两个参数按引用传递,一个图一个 matching,图被 copy,所以图无需回溯,matching 没有被 copy,所以 matching 需要回溯</li>
<li>操作图的时候 crud</li>
<li>copy 每一轮增加开销,直接操作则不增加开销,不过回溯可能不好写</li>
</ul>
<p><strong>matter D: maximumMtching</strong></p>
<pre><code class="language-cpp">Set&lt;Pair&gt; maximumWeightMatchingRec(const Map&lt;string, Map&lt;string, int&gt;&gt; links, Set&lt;Pair&gt; team) {
    //baseline
    if (links.isEmpty()) {
        return team;
    }

    //create a answer with value
    Map&lt;Set&lt;Pair&gt;, int&gt; possiblePairs = {};
    //select Current
    string person = links.firstKey();

    //consider all maps for Cur
    for (const string &amp; partner : links[person]) {
        //pruning :minus value not considered
        if (links[person][partner] &lt; 0) {
            continue;
        }
        //consider this case(choosen one)
        Pair pair = {person, partner};
        //copy version for graph
        auto backup = links;
        //change for choose
        backup.remove(person);
        backup.remove(partner);
        for (const string &amp; classmate : backup) {
            if (backup[classmate].containsKey(person)) {
                backup[classmate].remove(person);
            }
            if (backup[classmate].containsKey(partner)) {
                backup[classmate].remove(partner);
            }
        }

        Set&lt;Pair&gt; program = maximumWeightMatchingRec(backup, team + pair) + team;
        possiblePairs[program] = cal(links, program);
    }
    //new copy, the same as choose case
    auto backup = links;
    backup.remove(person);
    //not choose case
        //change for not choose
    for (const string &amp; classmate : backup) {
        if (backup[classmate].containsKey(person)) {
            backup[classmate].remove(person);
        }
    }
    //unchoose case
    Set&lt;Pair&gt; program = maximumWeightMatchingRec(backup, team);
    possiblePairs[program] = cal(links, program);

    team = possiblePairs.firstKey();
    //choose the highest case
    for (Set&lt;Pair&gt; combination : possiblePairs) {
        if (possiblePairs[combination] &gt; possiblePairs[team]) {
            team = combination;
        }
    }

    return team;
}
</code></pre>
<ul>
<li>数据结构的使用:一个图(map),一个 chosen(set)</li>
<li>在函数内部开一个记录 set 权值的 map,用来寻觅最大值开销大但是算法方便</li>
<li>回溯:不回溯,因为全是 copy</li>
</ul>
<p><strong>试修改版本</strong></p>
<pre><code class="language-cpp">Set&lt;Pair&gt; maximumWeightMatchingRec(const Map&lt;string, Map&lt;string, int&gt;&gt;&amp; links, Set&lt;Pair&gt;&amp; team) {
    //baseline
    if (links.isEmpty()) {
        return team;
    }

    //select Current
    string person = links.firstKey();

    //consider all maps for Cur
    for (const string &amp; partner : links[person]) {
        //pruning :minus value not considered
        if (links[person][partner] &lt; 0) {
            continue;
        }
        //consider this case(choosen one)
        Pair pair = {person, partner};
        //change for choose
            //copy version
        Map&lt;string, Map&lt;string, int&gt;&gt; backup = links;
        backup.remove(person);
        backup.remove(partner);
        for (const string &amp; classmate : backup) {
            if (backup[classmate].containsKey(person)) {
                backup[classmate].remove(person);
            }
            if (backup[classmate].containsKey(partner)) {
                backup[classmate].remove(partner);
            }
        }
        //method for choose max:change meta data
        Set&lt;Pair&gt; program = maximumWeightMatchingRec(backup, team + pair);
        int weight = cal(links, program);
        if (weight &gt; cal(links, team)) {
            team = program;
        }
    }
    //not choose case
    Map&lt;string, Map&lt;string, int&gt;&gt; backup = links;
    backup.remove(person);
    for (const string &amp; classmate : backup) {
        if (backup[classmate].containsKey(person)) {
            backup[classmate].remove(person);
        }
    }
    //unchoose case
    Set&lt;Pair&gt; program = maximumWeightMatchingRec(backup, team);
    int weight = cal(links, program);
    if (weight &gt; cal(links, team)) {
        team = program;
    }

    return team;
}
</code></pre>
<ul>
<li>if firstkey has x partners ,there are (x+1) cases</li>
<li>just find the max set for x+1 cases</li>
<li>trace method: <pre><code class="language-cpp">//choose the set for the heighst value
helper(Set&amp; A,Graph B){
    do one choose
    for (case:cases){
        pruning ;
        choose ;
        change A ;
        int value = cal(A) ;
        if (cal(current)&gt;value){
            A = current
        }
    }
    unchoose
    int value = cal(A) ;
    if (cal(current) &gt; value){
        A = current
    }
    return A ;
}
</code></pre>
<strong>matter E:wrong cases,minimum cover</strong></li>
</ul>
<pre><code class="language-cpp">bool canBeMadeDisasterReady(const Map&lt;string, Set&lt;string&gt;&gt;&amp; roadNetwork,
                            int numCities,
                            Set&lt;string&gt;&amp; supplyLocations) {
    //baseline
    if (numCities&lt;0){
        error(&quot;s&quot;);
    }
    if (supplyLocations.size()&gt;numCities){
        return false ;
    }
    if(supplyLocations.size() &lt;= numCities &amp;&amp; roadNetwork.isEmpty()){
        return true ;
    }
    string city = roadNetwork.firstKey();
    Set&lt;string&gt; Cur = roadNetwork[city];
    Cur.add(city);
    Map&lt;string, Set&lt;string&gt;&gt; copygraph = roadNetwork;
    for (string cover:Cur){
        Map&lt;string, Set&lt;string&gt;&gt; copy = roadNetwork;
        supplyLocations.add(cover);
        if (supplyLocations.size()&gt;numCities){
            supplyLocations.remove(cover);
            continue ;
        }
        for (string coverd:copygraph[cover]){
            copy.remove(coverd);
        }
        copy.remove(cover);
        if (canBeMadeDisasterReady(copy,numCities,supplyLocations)){
        }else{
            supplyLocations.remove(cover) ;
            continue ;
        }
    }
    return false ;
}
</code></pre>
<p>wrong :stack overflow,more precise,change procedure is wrong
reason :repeat covering by one specific city :wq
<strong>correct answer</strong></p>
<pre><code class="language-cpp">//helper function must be there
//separate args and calls 
bool canBeMadeDisasterReady(const Map&lt;string, Set&lt;string&gt;&gt;&amp; roadNetwork,
                            int numCities,
                            Set&lt;string&gt;&amp; supplyLocation){
                            //call error
    if (numCities &lt; 0) {
        error(&quot;num of supplied city less than 0&quot;);
    }
    Set&lt;string&gt; remaining;
    for (string city : roadNetwork) {
        remaining += city;
    }
    //remaining contains all citys
    return helper(roadNetwork, numCities, supplyLocations, remaining);
}
//helper function
//4 args 
bool helper(const Map&lt;string, Set&lt;string&gt;&gt; &amp; roadNetwork,
            int numCitys,
            Set&lt;string&gt;&amp; supplyLocations,
            Set&lt;string&gt;&amp; remaining) {
    if (numCitys &lt; 0) {
        return false;
    }
    if (remaining.isEmpty() &amp;&amp; numCitys &gt;= 0) {
        return true;
    }
    //there are only two cases
    // case 1:
    // choose one of the remaining to supplyLocations
    string choose = remaining.first();
    Set&lt;string&gt; neighbors = roadNetwork[choose];
    Set&lt;string&gt; left = remaining - choose - neighbors;
    supplyLocations += choose;     // choose
    if (helper(roadNetwork, numCitys - 1, supplyLocations, left)) {  // explore
        return true;
    }
    //back
    supplyLocations -= choose;  // unchoose

    // case 2: choose one of the remaining&#39;s neighbor to supplyLocations
    for (string neighbor : neighbors) {
        //neighbor will be covered
        //neighborsOfneighbor is citys coverd by neighbor
        Set&lt;string&gt; neighborsOfNeighbor = roadNetwork[neighbor];
        //left is a set about citys uncoverd
        Set&lt;string&gt; left = remaining - neighborsOfNeighbor - neighbor;
        supplyLocations += neighbor;
        //inplement by decreasing numCitys
        if (helper(roadNetwork, numCitys - 1, supplyLocations, left)) {
            return true;
        }
        //back
        supplyLocations -= ne ighbor;
    }
    return false;
}
</code></pre>
<p><strong>try correct version</strong> </p>
<ul>
<li>avoid repeating
(1 test fail)</li>
</ul>
<pre><code class="language-cpp">//TODO:fix
bool canBeMadeDisasterReady(const Map&lt;string, Set&lt;string&gt;&gt;&amp; roadNetwork,
                            int numCities,
                            Set&lt;string&gt;&amp; supplyLocations) {
    //baseline
    if (numCities &lt; 0){
        error(&quot;s&quot;);
    }
    if (supplyLocations.size() &gt; numCities ){
        return false ;
    }
    if(supplyLocations.size() &lt;= numCities &amp;&amp; roadNetwork.isEmpty()){
        return true ;
    }
    //choose current
    string city = roadNetwork.firstKey();
    Set&lt;string&gt; Cur = roadNetwork[city];
    Cur.add(city);

    for (string cover:Cur){
        if (supplyLocations.contains(cover)){
            continue ;
        }
        //copy
        Map&lt;string, Set&lt;string&gt;&gt; copy = roadNetwork;
        supplyLocations.add(cover);

        //pruning
        if (supplyLocations.size() &gt; numCities){
            supplyLocations.remove(cover);
            continue ;
        }
        //change
        for (string coverd:roadNetwork[cover]+cover){
            for (string curt:copy.keys()){
                if (copy[curt].contains(coverd)){
                    copy[curt].remove(coverd);
                }
            }
            copy.remove(coverd);
        }
        copy.remove(cover);
        //recursion
        if (canBeMadeDisasterReady(copy,numCities,supplyLocations)){
            return true ;
        }else{
            supplyLocations.remove(cover) ;
            continue ;
        }
    }
    return false ;
}
</code></pre>
<h4>Big-O,merge sort</h4>
<p><img src="../graph_bed/merge_sort_BIG_O.png" alt="BIg-O,merge_sort"></p>
<pre><code class="language-cpp">Vector&lt;DataPoint&gt; combineTwo(Vector&lt;DataPoint&gt;A,Vector&lt;DataPoint&gt;B){
    Vector&lt;DataPoint&gt; C = {} ;
    int num1 = A.size();
    int num2 = B.size();
    if (num1 == 0 &amp;&amp; num2 == 0){
        return C;
    }
    if (num1 == 0){
        C = B ;
        return C ;
    }
    if (num2 == 0){
        C = A ;
        return C ;
    }
    for (int i = 0;i &lt; num1 + num2;i++){
        if (A.isEmpty()){
            C.add(B.get(0)) ;
            B.remove(0);
            continue ;
        }
        if (B.isEmpty()){
            C.add(A.get(0)) ;
            A.remove(0);
            continue ;
        }
        if (A.get(0).weight &lt;= B.get(0).weight){
            C.add(A.get(0));
            A.remove(0);
            continue ;
        }else {
            C.add(B.get(0));
            B.remove(0) ;
            continue;
        }
    }
    return C ;
}
Vector&lt;DataPoint&gt; combine(const Vector&lt;Vector&lt;DataPoint&gt;&gt;&amp; sequences) {
    //spilt copy
    Vector&lt;DataPoint&gt; C = {};
    int num = sequences.size() ;
    if (num == 1){
        return sequences.get(0);
    }
    if(num == 0){
        return C ;
    }
    if (num % 2 == 0){
        Vector&lt;Vector&lt;DataPoint&gt;&gt; spilt1 = sequences.subList(0,num/2);
        Vector&lt;Vector&lt;DataPoint&gt;&gt; spilt2 = sequences.subList(num/2,num/2);
        Vector&lt;DataPoint&gt; ans1 = combine(spilt1);
        Vector&lt;DataPoint&gt; ans2 = combine(spilt2);
        Vector&lt;DataPoint&gt; ans = combineTwo(ans1,ans2);
        return ans;
    }
    if (num % 2 == 1){
    Vector&lt;Vector&lt;DataPoint&gt;&gt; spilt1 = sequences.subList(0,(num-1)/2);
    Vector&lt;Vector&lt;DataPoint&gt;&gt; spilt2 = sequences.subList((num-1)/2,(num-1)/2);
    Vector&lt;DataPoint&gt; ans1 = combine(spilt1);
    Vector&lt;DataPoint&gt; ans2 = combine(spilt2);
    Vector&lt;DataPoint&gt; ans3 = combineTwo(ans1,ans2);
    Vector&lt;DataPoint&gt; ans4 = sequences.get(num - 1) ;
    Vector&lt;DataPoint&gt; ans = combineTwo(ans3,ans4);
    return ans ;
    }
    return C ;
}
</code></pre>
<ul>
<li>combineTwo is to make two vector sorted</li>
<li>combine is a recursion to get vectors combined to a huge sorted vector</li>
<li>shorts : cause the &#39;A.remove(0)&#39;,time wasted</li>
</ul>
<p><strong>improvements: from tail to head</strong></p>
<pre><code class="language-cpp">Vector&lt;DataPoint&gt; combineTwo(Vector&lt;DataPoint&gt;A,Vector&lt;DataPoint&gt;B){
    Vector&lt;DataPoint&gt; C = {} ;
    int num1 = A.size();
    int num2 = B.size();
    if (num1 == 0 &amp;&amp; num2 == 0){
        return C;
    }
    if (num1 == 0){
        C = B ;
        return C ;
    }
    if (num2 == 0){
        C = A ;
        return C ;
    }
    for (int i = 0;i &lt; num1 + num2;i++){
        int numA = A.size() - 1;
        int numB = B.size() - 1;
        if (A.isEmpty()){
            C.add(B.get(numB));
            B.remove(numB );
            continue;
        }
        if (B.isEmpty()){
            C.add(A.get(numA));
            A.remove(numA);
            continue ;
        }
        if (A.get(numA).weight &gt;= B.get(numB).weight){
            C.add(A.get(numA));
            A.remove(numA);
            continue ;
        }else {
            C.add(B.get(numB));
            B.remove(numB);
            continue;
        }
    }
    Vector&lt;DataPoint&gt; D = {};
    while (C.size()&gt;0){
        D.add(C.get(C.size()-1));
        C.remove(C.size() - 1);
    }
    return D ;
}
</code></pre>
<ul>
<li>from the tail to head to remove, faster</li>
<li>wonderful</li>
</ul>
<p><strong>algorithm graph</strong>
<img src="../graph_bed/merge_sort_time.png" alt="runing time">
<code>O(nlogk)</code></p>
<h4>debug 技巧:recursion</h4>
<ul>
<li>三种方式:按断点,单步跳过,单步跳入,单步跳出</li>
<li>(如果代码出错)运行run时程序会直接崩溃(无法debug),debug会停在崩溃的位置</li>
</ul>
<h2>第四单元 object oriental programming</h2>
<p><strong>类</strong>
class 三步走 1.成员变量 2.成员函数 3.构造器</p>
<h3>内存管理与debug</h3>
<p><strong>exploreArrays</strong></p>
<pre><code class="language-cpp">void exploreArrays() {
    /* In this section, you&#39;ll see how to use the debugger to read the contents
     * of arrays in memory and how to recognize when you&#39;re trying to read past
     * the end of an array.
     *
     * Begin by setting a breakpoint on the line of code shown below, then doing
     * execute the &quot;Step Over&quot; command until you&#39;re at the next comment.
     */
    DataPoint* elems = new DataPoint[4] {
        { &quot;What&quot;,      1 },
        { &quot;a&quot;,         2 },
        { &quot;wonderful&quot;, 3 },
        { &quot;world!&quot;,    4 },
    };

    /* At this point, you now have a nice array of elements in memory. If you
     * try using the debugger to read that array, though, you&#39;ll probably only
     * see the first element of that array.
     *
     * To fix this, we&#39;ll need to tell the debugger to change the display
     * format for elems. To do so, right-click on &quot;elems&quot; in the debugging
     * window that shows local variable values. You should see two groups of
     * options in the menu. One group be marked &quot;Change Display for Object
     * Named local.elems,&quot; and the other will be marked &quot;Change Display for
     * Type DataPoint*.&quot; In the group for &quot;Object Named local.elems,&quot; choose
     * the option &quot;Array of 10 items.&quot; When you do, you should see ten drop-
     * down slots appear underneath elems.
     *
     * Expand out slots [0], [1], [2], and [3] and confirm that you can read
     * the values there and that they match what was created in the array
     * above. You should see the data and weight fields. (You&#39;ll also see
     * one called _initializationFlag. This is something extra we added for
     * this assignment to make it easier to spot memory errors, and you can
     * safely ignore it.)
     *
     * Once you&#39;ve done that, hit &quot;Step Over&quot; to skip this line of code.
     */
    elems[0].weight++; // Just a place for the debugger to rest.

    /* Now, expand out slots [4], [5], [6], ..., and [9]. These slots aren&#39;t
     * actually a part of the array, and they&#39;re essentially garbage values
     * that appear past the end of the array we allocated up above. Some of
     * the strings you&#39;ll see might be marked &lt;not accessible&gt;, while others
     * might be empty, or might be random sequences of symbols. The numbers
     * that you see on the different slots are similarly unpredictable - they
     * might happen to be all zeros, or they might be completely random values
     * with no discernable pattern.
     *
     * Hit &quot;Step Over&quot; to skip this next line and move on to the next section.
     */
    elems[0].weight++; // Just a place for the debugger to rest.

    /* This next section of code allocates space for three DataPoints, but
     * doesn&#39;t initialize them. Hit &quot;Step Over&quot; to set that array up.
     *
     * (Yes, we just leaked a bunch of memory. That&#39;s not a good thing, but
     * this is purely for educational purposes and so we don&#39;t care. ^_^)
     */
    elems = new DataPoint[3];

    /* Now, poke around a bit in the debugger and look at the array contents.
     * Look at slots [0], [1], and [2] (the valid slots in the array.)
     * We didn&#39;t initialize any of the elements in this array, so C++ does
     * what it normally does when initializing those elements. In particular,
     * notice that
     *
     * 1. the strings have all been set to the empty string, and
     * 2. the integers are all essentially random.
     *
     * Now, move on and look at slots [3], [4], ..., [9]. Notice that the
     * integers here all look pretty much random as well, but the strings here
     * are likely to be a mix of empty, &lt;not accessible&gt;, and totally random.
     *
     * We wanted you to see this because we want you to understand that seeing
     * garbage values in memory doesn&#39;t necessarily mean that you&#39;ve walked off
     * the end of the array. Rather, it likely means that you&#39;re seeing some
     * values in memory that weren&#39;t initialized. So don&#39;t panic if you see
     * this when writing code that uses arrays - it doesn&#39;t mean that your
     * pointer is &quot;bad&quot; or something like that. It could very well mean that
     * you have the space you need, but just forgot to initialize the values
     * there.
     */
    elems[0].weight = 137; // Ah, give a nice value.

    /* To wrap up this section, edit res/ShortAnswers.txt with your answers
     * to the following questions:
     *
     * Q1: What operating system are you using? (Windows, macOS, Linux, etc.)
     *
     * Q2: What are the values you see in elems[3], elems[4], and elems[5]? If
     *     you see garbage strings that run for long periods of time, just give
     *     us the first few characters, or your best approximation of them. :-)
     *
     */
    elems[1].weight = 137; // Just another place for the debugger to chill.
}
</code></pre>
<ul>
<li>the strings have all been set to the empty string, and</li>
<li>the integers are all essentially random.</li>
</ul>
<p><strong>内存泄漏</strong></p>
<ul>
<li>无指针释放环节</li>
</ul>
<p><strong>priority queues</strong></p>
<ul>
<li>head file</li>
</ul>
<pre><code class="language-cpp">class HeapPQueue {
public:
    /**
     * Creates a new, empty priority queue.
     */
    HeapPQueue();

    /**
     * Cleans up all memory allocated by this priorty queue. Remember, you&#39;re responsible
     * for managing your own memory!
     */
    ~HeapPQueue();

    /**
     * Adds a new data point into the queue. This operation runs in time O(log n),
     * where n is the number of elements in the queue.
     *
     * @param data The data point to add.
     */
    void enqueue(const DataPoint&amp; data);

    /**
     * Removes and returns the lowest-weight data point in the priority queue. If multiple
     * elements are tied for having the loweset weight, any one of them may be returned.
     *
     * If the priority queue is empty, this function calls error() to report an error.
     *
     * This operation must run in time O(log n), where n is the number of elements in the
     * queue.
     *
     * @return The lowest-weight data point in the queue.
     */
    DataPoint dequeue();

    /**
     * Returns, but does not remove, the element that would next be removed via a call to
     * dequeue.
     *
     * If the priority queue is empty, this function calls error() to report an error.
     *
     * This operation must run in time O(1).
     *
     * @return
     */
    DataPoint peek() const;

    /**
     * Returns whether the priority queue is empty.
     *
     * This operation must run in time O(1).
     *
     * @return Whether the priority queue is empty.
     */
    bool isEmpty() const;

    /**
     * Returns the number of data points in this priority queue.
     *
     * This operation must run in time O(1).
     *
     * @return The number of elements in the priority queue.
     */
    int  size() const;

    /* This function exists purely for testing purposes. You can have it do whatever you&#39;d
     * like and we won&#39;t be invoking it when grading. In the past, students have had this
     * function print out the array representing the heap, or information about how much
     * space is allocated, etc. Feel free to use it as you see fit!
     */
    void printDebugInfo();

private:
    /* Pointer to the array of elements. Our tests expect your implementation to use the
     * name &#39;elems&#39; for the pointer to the array of elements, so please do not rename this
     * variable.
     */
    DataPoint* elems = nullptr;

    /* Logical size of the priority queue (the number of elements stored in the heap).
     * Our tests expect that this variable exists, so please do not rename this variable.
     */
    int logicalSize = 0;

    /* Allocated size of the priority queue (the number of slots used in the heap).
     * Our tests expect that this variable exists, so please do not rename this variable.
     */
    int allocatedSize = 0;

    /* Constant controlling how big the original array should be.
     *
     * We&#39;ve picked this value because it&#39;s large enough to hold
     * a small number of elements for when you&#39;re just getting
     * started, but small enough that it&#39;s easy to test resizing
     * behavior. You shouldn&#39;t edit this value.
     */
    static const int INITIAL_SIZE = 6;

    /* TODo: Add any private member variables, member functions, or member
     * types that you&#39;d like. You&#39;re welcome to implement this type however
     * you&#39;d like, provided that you do all your own memory management, you
     * don&#39;t use any container types (e.g. Vector, HashSet, etc.), and that
     * your implementation uses a binary heap.
     *
     * TODO: Delete this comment before submitting.
     */
    int son1(int index) ;
    int son2(int index);
    int father(int index);
    void expend ();


    /* By default, C++ will let you copy objects. The problem is that the default copy
     * just does an element-by-element copy, which with pointers will give invalid results.
     * This macro disables copying of this type. For more details about how this works, and
     * for more information about how to override the default behavior, take CS106L!
     */
    DISALLOW_COPYING_OF(HeapPQueue);

    /* Grants STUDENT_TEST and PROVIDED_TEST access to the private section of this class.
     * This allows tests to check private fields to make sure they have the right values
     * and to test specific helper functions.
     */
    ALLOW_TEST_ACCESS();
};
</code></pre>
<ul>
<li>inplemention</li>
</ul>
<pre><code class="language-cpp">#include &quot;HeapPQueue.h&quot;
using namespace std;

HeapPQueue::HeapPQueue() {
    elems =  new DataPoint[INITIAL_SIZE] ;
    allocatedSize = INITIAL_SIZE ;
    logicalSize = 0 ;
    if (elems != nullptr){
        for (int i=1;i&lt;sizeof(elems);i++){
            elems[i].weight = 0 ;
        }
    }
}

HeapPQueue::~HeapPQueue() {
    /* TODo: Implement this. */
    delete []elems ;
}

int HeapPQueue::size() const {
    return logicalSize ;
}

bool HeapPQueue::isEmpty() const {
    if (logicalSize == 0){
        return true ;
    }
    else {
        return false ;
    }
}

void HeapPQueue::enqueue(const DataPoint&amp; data) {
    /* TODo: Delete the next line and implement this. */
    if (logicalSize == allocatedSize - 1){
        HeapPQueue::expend();
    }
    logicalSize++ ;
    elems[logicalSize] = data ;
    int i = logicalSize ;

    while (father(i) &gt; 0) {
        if (elems[i].weight &lt; elems[father(i)].weight){
            swap(elems[i],elems[father(i)]) ;
            i = father(i);
        }
        else {
            return ;
        }
    }
    return ;
}

DataPoint HeapPQueue::peek() const {
    if (elems == nullptr){
        return {};
    }
    if (logicalSize == 0){
        error(&quot;s&quot;);
    }
    /* TODo: Delete the next line and implement this. */
    return elems[1] ;
}

DataPoint HeapPQueue::dequeue() {
    if (logicalSize == 0){
        error(&quot;s&quot;);
    }
    /* TODo: Delete the next line and implement this. */
    if (elems == nullptr){
        return {};
    }
    DataPoint ans = elems[1];
    elems[1] = elems[logicalSize] ;
    logicalSize-- ;
    int son  = 0;
    for(int i = 1;;i = son ){
        if (son1(i) &gt; logicalSize){
            if (son2(i)&gt;logicalSize){
                break ;
            }
            else {
                son = son2(i);
            }
        }
        else {
            if (son2(i)&gt;logicalSize){
                son = son1(i);
            }
            else {
                if (elems[son1(i)].weight &lt; elems[son2(i)].weight){
                    son = son1(i);
                }else {
                    son = son2(i);
                }
            }
        }
        //swap
        if (elems[i].weight &gt; elems[son].weight){
            swap(elems[i],elems[son]) ;
        }
        else {
            return ans;
        }
    }
    return ans;
}
int HeapPQueue::son1(int index) {
    int son1 = 2*index;
    return son1 ;
}
int HeapPQueue::son2(int index){
    int son2 = 2*index + 1 ;
    return son2 ;
}
int HeapPQueue::father(int index)
{
    if (index % 2 == 0){
        return index / 2 ;
    }
    if (index % 2 == 1){
        return (index - 1)/2 ;
    }
    return 0 ;
}
void HeapPQueue::expend (){
    DataPoint * newelems = nullptr ;
    newelems = new DataPoint[2 * allocatedSize];
    if (newelems!=nullptr){
        for (int i=1;i&lt;logicalSize + 1;i++){
            newelems[i] = elems[i];
        }
    }

    delete []elems ;
    elems = newelems ;

    allocatedSize = allocatedSize * 2;
}
</code></pre>
<ul>
<li>the way to store binary heap in array</li>
<li>bubble ways</li>
</ul>
<p><strong>the use for heapPQueue:Apportionment</strong>
try to make it <code>O(nlogk)</code></p>
<pre><code class="language-cpp">Map&lt;string, int&gt; apportion(const Map&lt;string, int&gt;&amp; populations, int numSeats) {
    /* TOD: Delete this line and the lines below it, then implement this function. */
    if (populations.size()&gt;numSeats){
        error(&quot;s&quot;) ;
    }
    HeapPQueue condition ;
    HeapPQueue conditioncopy ;
    Map&lt;string, int&gt; ans = {};
    //初始化
    for (string key:populations){
        ans.put(key,1);
    }
    for (string key:populations){
        if (ans[key] == 1){
            DataPoint ans1 = {key,populations[key]/sqrt(2)} ;
            condition.enqueue(ans1) ;
        }
    }
    //分配席位
    for (int num = 0 ; num &lt; numSeats - populations.size() ; num++){
        //分配席位,欺骗状态优先级队列
        DataPoint statet ;
        while (!condition.isEmpty()){
            statet = condition.dequeue();
            conditioncopy.enqueue(statet) ;
        }
        //最高权重name
        string stateName = statet.name ;
        //最高权重新席位数
        int newnum = ans[stateName] + 1 ;
        ans.put(stateName,newnum) ;
        //最高权重人口
        int pop = populations[stateName] ;
        //计算最高权重的新值
        DataPoint newdata = {stateName,pop/sqrt(newnum*(newnum + 1))} ;
        condition.enqueue(newdata) ;
        //从copy中取,重新注入condition
        DataPoint statetcopy ;
        while (!conditioncopy.isEmpty()){
            statetcopy = conditioncopy.dequeue() ;
            if (statetcopy!=statet){
                condition.enqueue(statetcopy) ;
            }
        }
    }
    return ans ;
}
</code></pre>
<p>超时,重写,很简单,我们打入倒数(所以cs中返回最的函数必然既能最大值也能返回最小值,只需颠倒)</p>
<pre><code class="language-cpp">Map&lt;string, int&gt; apportion(const Map&lt;string, int&gt;&amp; populations, int numSeats) {
    if (populations.size()&gt;numSeats){
        error(&quot;s&quot;) ;
    }
    HeapPQueue condition ;
    Map&lt;string, int&gt; ans = {};
    //初始化
    for (string key:populations){
        ans.put(key,1);
    }
    for (string key:populations){
        if (ans[key] == 1){
            DataPoint ans1 = {key,sqrt(2)/populations[key]} ;
            condition.enqueue(ans1) ;
        }
    }
    //分配席位
    for (int num = 0 ; num &lt; numSeats - populations.size() ; num++){
        //分配席位,欺骗状态优先级队列
        DataPoint statet ;
        statet = condition.dequeue();

        //最高权重name
        string stateName = statet.name ;
        //最高权重新席位数
        int newnum = ans[stateName] + 1 ;
        ans.put(stateName,newnum) ;
        //最高权重人口
        int pop = populations[stateName] ;
        //计算最高权重的新值
        DataPoint newdata = {stateName,sqrt(newnum*(newnum + 1))/pop} ;
        condition.enqueue(newdata) ;
    }
    return ans ;
}
</code></pre>
<p>完美通过</p>
<h2>第五单元-links and some real world algorithms</h2>
<ul>
<li>链表</li>
<li>bitnary search trees</li>
<li>huffman code </li>
<li>hashing</li>
</ul>
<h3>Huffman encodding</h3>
<p><strong>provably minimal encoding</strong> 
<strong>PROBLEM</strong>:通过编码的方式压缩信息(01),如何压缩到最小情况
一些显而易见的事实</p>
<ul>
<li>出现最多的信息应该用最短的编码</li>
<li>出现最少的信息应该用最长的编码</li>
<li>关键点:如何确定频率和编码之间的关系
  思考1:先编码低频,再编码高频,遵循prefix 原则,所以用到的是优先级队列
  思考2:如何确定优先级的分配呢?</li>
</ul>
<p><strong>Huffman code example</strong>
code for KIDR&#39;S 
<img src="../graph_bed/Huffman_example1.png" alt="Huffman code example">
<strong>huffman code .cpp</strong></p>
<pre><code class="language-cpp">//准备,数据结构
#include &quot;Huffman.h&quot;
using namespace std;

//内存回收,递归实现
void deleteTree(EncodingTreeNode* tree) {
    if (tree!=nullptr) {
        deleteTree(tree-&gt;zero);
        deleteTree(tree-&gt;one);
        delete tree;
    }else {
        return ;
    }
}
/*  
输入:str
输出:Huffman tree
*/
EncodingTreeNode* huffmanTreeFor(const string&amp; str) {
    //空字符串报错
    if (str.size() == 0){
        error(&quot;s&quot; ) ;
    }
    //优先级队列
    PriorityQueue&lt;EncodingTreeNode*&gt; pq;
    Map&lt;char ,int&gt; prioritys ;
    //字典
    for (char A:str){
        prioritys.put(A,0) ;
    }
    for (char A:str){
        prioritys[A]++;
    }
    //如果只有一个节点,报错
    if (prioritys.size() == 1){
        error (&quot;s&quot;) ;
    }
    //打入优先级队列
    for (char A:prioritys){
        EncodingTreeNode* ans = new EncodingTreeNode[1];
        ans-&gt;ch = A ;
        ans-&gt;one = nullptr ;
        ans-&gt;zero = nullptr ;
        pq.enqueue(ans,prioritys.get(A)) ;
    }
    //头节点
    EncodingTreeNode* head = nullptr ;
    while(pq.size() &gt; 1){

        EncodingTreeNode* current1 = pq.dequeue();
        EncodingTreeNode* current2 = pq.dequeue();
        int value1 = prioritys.get(current1-&gt;ch) ;
        int value2 = prioritys.get(current2-&gt;ch) ;


        //current 12
        EncodingTreeNode *head12 = new EncodingTreeNode[1] ;
        head12-&gt;zero = current1 ;
        head12-&gt;one = current2 ;
        head12-&gt;ch = current1-&gt;ch ;

        head = head12 ;
        pq.enqueue(head12,value1 + value2) ;
    }

    return head ;
}
/*
输入:Huffman tree,解码队列bits
输出:解码结果str
*/
string decodeText(Queue&lt;Bit&gt;&amp; bits, EncodingTreeNode* tree) {
    string ans ;
    EncodingTreeNode* temptree = tree ;
    if (temptree == nullptr){
        error(&quot;s&quot;) ;
    }
    //当bits不为空的时候保持搜索,0对应左,1对应右,触底则记录得到的char,加入ans
    while(bits.size() &gt; 0){
        if (temptree-&gt;zero!=nullptr &amp;&amp; temptree-&gt;one!=nullptr){
            Bit cur = bits.dequeue() ;
            //
            if (cur == 0){
                temptree = temptree-&gt;zero ;
            }
            //
            if (cur == 1){
                temptree = temptree-&gt;one ;
            }
            continue ;
        }else {
            ans = ans + temptree-&gt;ch ;
            temptree = tree;
        }
    }
    //最后一个要补
    ans = ans + temptree-&gt;ch ;
    return ans ;
}
/*
输入:待寻找的char A,已有的Huffman tree
输出:A对应的路径
*/

Queue&lt;Bit&gt; encodeText(const string&amp; str, EncodingTreeNode* tree) {
    Queue&lt;Bit&gt; ans ;
    //一个一个搜索
    for (char A:str){
        Queue&lt;Bit&gt; path ;
        path = encodeTexthelper(A,tree,path) ;
        while (path.size()&gt; 0){
            Bit S = path.dequeue() ;
            ans.enqueue(S) ;
        }
    }
    return ans ;
}

Queue&lt;Bit&gt; encodeTexthelper(char &amp;A, EncodingTreeNode* tree,Queue&lt;Bit&gt; path) {
    //base lines
    if (tree-&gt;one == nullptr){
        //触底返回已有路径
        if (tree-&gt;ch == A){
            return path ;
        }else {
            return  {};
        }
    }
    //分叉成两条路
    Queue&lt;Bit&gt; path1 = path ;

    Queue&lt;Bit&gt; path2 = path ;

    path1.enqueue(0) ;
    path2.enqueue(1) ;
    //走
    Queue&lt;Bit&gt; ans1 = encodeTexthelper(A,tree-&gt;zero,path1) ;
    Queue&lt;Bit&gt; ans2 = encodeTexthelper(A,tree-&gt;one,path2) ;
    //返回合法的路径
    if (ans1.size()&gt;0){
        return ans1;
    }else {
        return ans2 ;
    }
}

EncodingTreeNode* decodeTree(Queue&lt;Bit&gt;&amp; bits, Queue&lt;char&gt;&amp; leaves) {
    //直接使用helper
    EncodingTreeNode* head = decodeTreehelper(bits,leaves);

    return head ;
}
/*
    输入:树的形状和叶子
    输出:树节点
    思路:分割bits队列,使得原问题转化为两个树的生成问题
*/
EncodingTreeNode* decodeTreehelper(Queue&lt;Bit&gt;&amp; bits, Queue&lt;char&gt;&amp; leaves) {
    Bit cur = bits.dequeue();
    EncodingTreeNode* head ;
    //第一节点
    if (cur == 1){
        EncodingTreeNode* head12 = new EncodingTreeNode[1] ;
        int exceptvalue = 1;
        //待分割
        Queue&lt;Bit&gt; bits1;
        Queue&lt;Bit&gt; bits2 ;
        //分割算法
        int realget = 0;
        head = head12 ;
        while(exceptvalue &gt; realget){
                Bit cur = bits.dequeue();
                if (cur == 1 ){
                        exceptvalue = exceptvalue +1;
                        bits1.enqueue(cur) ;
                }
                if (cur == 0){
                    bits1.enqueue(cur) ;
                    realget++;
                }
        }
        //已经得到bits1,下面得到bits2
        while(!bits.isEmpty()){
            Bit cur = bits.dequeue();
            bits2.enqueue(cur) ;
        }
        //分割成功,使用递归
        head12-&gt;zero = decodeTreehelper(bits1,leaves);
        head12-&gt;one = decodeTreehelper(bits2,leaves);
    }else {
        //如果第一节点就是叶子
        EncodingTreeNode* tree1 = new EncodingTreeNode[1] ;
        tree1-&gt;ch = leaves.dequeue() ;
        tree1-&gt;zero = nullptr ;
        tree1-&gt;one = nullptr ;
        return tree1 ;
    }

    return head ;
}
/*
    输入:Huffman树
    输出:无
    改变参数:树的形状队列和叶子内容(char)

*/
void encodeTree(EncodingTreeNode* tree, Queue&lt;Bit&gt;&amp; bits, Queue&lt;char&gt;&amp; leaves) {
    encodeTreehelper(tree,bits,leaves) ;
}
//helper
void encodeTreehelper(EncodingTreeNode* tree,
                      Queue&lt;Bit&gt;&amp; bits,
                      Queue&lt;char&gt;&amp; leaves){
    //把记录一个树的形状和叶子的问题转化为记录两个子树的问题
    if (tree-&gt;one == nullptr){
        //开局就是叶子
        leaves.enqueue(tree-&gt;ch) ;
        bits.enqueue(0);
    }else {
        bits.enqueue(1);
        encodeTreehelper(tree-&gt;zero,bits,leaves) ;
        encodeTreehelper(tree-&gt;one,bits,leaves) ;
    }
}
//综合函数,压缩
HuffmanResult compress(const string&amp; text) {
    //输入合法性检验
    if (text.size() &lt;= 1){
        error(&quot;S&quot;) ;
    }
    char testcopy = text.at(0) ;
    char test;

    for (int i=1;i&lt;text.size();i++){
        test = text.at(i);
        if (test != testcopy){
            goto labhea ;
        }
    }
    error(&quot;S&quot;) ;
labhea :
    //Huffman结果
    HuffmanResult ans;

    EncodingTreeNode *head = huffmanTreeFor(text) ;
    //结果的三个部分
    Queue&lt;Bit&gt; ansbits ;
    Queue&lt;char&gt; anstreeleaves;
    Queue&lt;Bit&gt; ansmessageBits;
    //填入答案
    encodeTree(head,ansbits,anstreeleaves);
    ansmessageBits = encodeText(text,head) ;

    ans.messageBits = ansmessageBits;
    ans.treeBits = ansbits;
    ans.treeLeaves = anstreeleaves ;
    //释放内存
    deleteTree(head) ;

    return ans;

}
//解压
string decompress(HuffmanResult&amp; file) {
    EncodingTreeNode* head = decodeTree(file.treeBits,file.treeLeaves);
    string ans = decodeText(file.messageBits,head);
    deleteTree(head) ;
    return ans ;
}
</code></pre>
<h3>hashing</h3>
<p>hashing: <strong>一个单射函数</strong>
<strong>PROBLEM</strong> :如何使ADT达到比O(logn)更快的效果?</p>
<ul>
<li>利用hashing fn 生成hashing value</li>
<li>创造桶(bucket),根据hashing value对应桶,把元素存入桶中</li>
<li>读取时,同样根据hashing value 读取元素所在的桶,然后在这个桶里面寻找元素</li>
<li>a hashing collision is about one bucket holding two elements&#39;</li>
<li>we use chaining to solve collision,storing elements in links in a bucket (a hashing node)
<img src="../graph_bed/hashing_load_factor1.png" alt="hashing_load_factor">
其中n是总元素,b是桶数量,idl(insertion,delegate,lookup)复杂度 O(1+n/b) </li>
<li>if <code>\alpha &gt; c</code>, then rehash(resize the num of buckets to make alpha constrained)</li>
<li>hashing also is used in encryption</li>
</ul>
<p><strong>一种较为基本简单的线性探测哈希设计,不包含rehash</strong></p>
<pre><code class="language-cpp">class LinearProbingHashTable {
public:
    //构造函数
    LinearProbingHashTable(HashFunction&lt;std::string&gt; hashFn);
    //析构函数
    ~LinearProbingHashTable();
    //判空,O(1)复杂度
    bool isEmpty() const;
    //返回已存入元素数量,O(1)
    int size() const;
    //插入
    bool insert(const std::string&amp; key);
    //判含
    bool contains(const std::string&amp; key) const;
    //删除
    bool remove(const std::string&amp; key);

private:
    //slot的三种状态
    enum class SlotType {
        EMPTY, FILLED, TOMBSTONE
    };
    //slot构造
    struct Slot {
        std::string value;
        SlotType type;
    };
    //slot指针
    Slot* elems = nullptr;
    //已存入元素
    int numelems ;
    //一个linerprobinghash的hash函数
    HashFunction&lt;std::string&gt; hashFn;
    //容量
    int capacity ;
};
</code></pre>
<p>具体实现:</p>
<pre><code class="language-cpp">LinearProbingHashTable::LinearProbingHashTable(HashFunction&lt;string&gt; hashFn) {
    //存入hash函数
    this-&gt;hashFn = hashFn ;
    //记录本次容量
    capacity = hashFn.numSlots() ;
    //分配内存
    elems = new Slot[capacity] ;
    //初始化
    for (int i=0 ;i &lt; capacity ;i++){
        elems[i].type = SlotType::EMPTY ;
        elems[i].value = &quot;&quot; ;
    }
    numelems = 0;
}

LinearProbingHashTable::~LinearProbingHashTable() {
    //释放内存
    delete []elems ;
}

int LinearProbingHashTable::size() const {
    //直接返回记录值
    return numelems ;
}

bool LinearProbingHashTable::isEmpty() const {
    //依托于记录值判空
    if (numelems == 0){
        return true ;
    }else {
        return false ;
    }
}

/*理论上,remove改进情况下,应该只有两种状态,empty和filled,稍作修改条件即可*/
bool LinearProbingHashTable::insert(const string&amp; elem) {
    //拒绝重复插入
    if (LinearProbingHashTable::contains(elem)){
        return false ;
    }
    //获得哈希值
    int elemhashValue = hashFn(elem) ;
    //得到index
    int index = elemhashValue % capacity ;
    //制作副本,让指针只跑一个周期
    int indexcopy = index;
    //得到指针
    Slot* cur = &amp;elems[index] ;
    //获得非filled位置的指针
    while (cur-&gt;type == SlotType::FILLED){
        //如果达到边界,环形数组,或者index++
        if (index == capacity - 1){
            index = 0;
        }else {
            index++ ;
        }
        //如果跑完一圈,false
        if (index == indexcopy){
            return false ;
        }
        //后置的获取指针
        cur = &amp;elems[index] ;
    }
    //在empty位置插入
    cur-&gt;value = elem ;
    cur-&gt;type = SlotType::FILLED ;
    numelems++;
    return true ;
}
/*理论上,remove改进情况下,应该只有两种状态,empty和filled,稍作修改条件即可*/
bool LinearProbingHashTable::contains(const string&amp; elem) const {
    //获得哈希值
    int elemhashValue = hashFn(elem) ;
    //获得index
    int index = elemhashValue % capacity ;
    //获得指针
    Slot* cur = &amp;elems[index] ;
    //获得index副本
    int indexcopy = index ;
    //在有值区域移动,最后得到empty位置指针
    while (cur-&gt;type !=SlotType::EMPTY){
        //如果有值且被填充
        if (cur-&gt;value == elem&amp;&amp;cur-&gt;type == SlotType::FILLED){
            return true ;
        }
        //边界
        if (index == capacity - 1){
            index = 0;
        }else {
            index ++ ;
        }
        //跑一圈
        if (index == indexcopy){
            return false ;
        }
        //后置获取指针
        cur = &amp;elems[index] ;
    }
    return false  ;
}
/*实际上remove可以改进,不需要第三种标记状态,在remove后直接rehash*/
bool LinearProbingHashTable::remove(const string&amp; elem) {
    //获取hash值
    int elemhashValue = hashFn(elem) ;
    //获取index
    int index = elemhashValue % capacity ;
    //获取指针
    Slot* cur = &amp;elems[index] ;
    //获取index副本
    int indexcopy = index ;
    //在非空区域移动
    while (cur-&gt;type != SlotType::EMPTY){
        //如果是被删除区域
        if (cur-&gt;type == SlotType::TOMBSTONE){
            //环形数组的边界
            if (index == capacity - 1){
                index = 0 ;
            }else {
                index++ ;
            }
            //跑一圈
            if (index == indexcopy){
                return false;
            }
            //后置获取指针
            cur = &amp;elems[index];
            continue ;
        }
        //找到remove目标
        if (cur-&gt;value == elem){
            cur-&gt;type = SlotType::TOMBSTONE ;
            numelems-- ;
            return true ;
        }else {
            if (index == capacity - 1){
                index = 0 ;
            }else {
                index ++ ;
            }
            if (index == indexcopy){
                return false;
            }
            cur = &amp;elems[index];
        }
    }
    return false ;
}
</code></pre>
<p><strong>改进方案</strong></p>
<ul>
<li>只需要两种状态</li>
<li>remove之后直接rehash(将原来的元素全部重新打入新table)</li>
<li>应该有自动扩大内存功能</li>
<li>functions: rehash,expand</li>
<li>key points:copy all elems
<strong>liner probing hashing:a collision resolution</strong></li>
</ul>
<p><strong>一种较为简单的Robin hash</strong></p>
<ul>
<li>Each element in a Robin Hood hash table is annotated with the distance it is from its home slot. This distance is measured by the number of steps backwards you have to take, starting at that element, to get the index of its home slot. (As in linear probing, we wrap around the ends of the table if we reach that point.)</li>
<li>Lookups in a Robin Hood hash table can stop early. Specifically, if the element we’re looking for is further from home than the currently-scanned table element, we know that the element we’re looking for isn’t in the table and can stop our search. </li>
<li>When inserting an element into a Robin Hood hash table, if the element being inserted is further from home than the element in the table slot being scanned, we displace the element in the table at that index, place the element we wanted to insert there, then continue onward as if we were inserting the displaced element all along. (We do not do anything if the distances are tied.)</li>
<li>There are no tombstones in a Robin Hood hash table. Instead, when deleting an element, we use backwards-shift deletion: we shift elements back one spot in the table until we either (1) find an empty slot or (2) find an element in its natural home spot.</li>
</ul>
<p><strong>.h</strong></p>
<pre><code class="language-cpp">class RobinHoodHashTable {
public:
    //构造函数
    RobinHoodHashTable(HashFunction&lt;std::string&gt; hashFn);
    //析构
    ~RobinHoodHashTable();
    //判空
    bool isEmpty() const;
    //数数
    int size() const;
    //插入,使用Robin设计
    bool insert(const std::string&amp; key);
    //判含,使用Robin设计
    bool contains(const std::string&amp; key) const;
    //移除,使用shift-back法
    bool remove(const std::string&amp; key);

//    void printDebugInfo() const;

private:
   //插槽
    struct Slot {
        std::string value;
        int distance;
    };
    //空
    static const int EMPTY_SLOT = -137;
    //元素数量
    int numelems ;
    //容量
    int capacity ;
    //内置hash函数
    HashFunction&lt;std::string&gt; hashFn ;
    //插槽指针
    Slot* elems = nullptr;



    //辅助内容
    /* Internal shenanigans to make this play well with C++. */
    DISALLOW_COPYING_OF(RobinHoodHashTable);
    ALLOW_TEST_ACCESS();
    MAKE_PRINTERS_FOR(Slot);
    MAKE_COMPARATORS_FOR(Slot);
};
</code></pre>
<p><strong>实现</strong></p>
<pre><code class="language-cpp">//构造函数
RobinHoodHashTable::RobinHoodHashTable(HashFunction&lt;string&gt; hashFn) {
    //存入构造函数
    this-&gt;hashFn = hashFn ;
    //
    capasity = hashFn.numSlots() ;
    //
    elems = new Slot[capasity] ;
    //初始化
    for (int i=0 ;i &lt; capasity ;i++){
        elems[i].distance = EMPTY_SLOT ;
        elems[i].value = &quot;&quot; ;
    }
    numelems = 0;
}

RobinHoodHashTable::~RobinHoodHashTable() {
    delete[] elems ;
}

int RobinHoodHashTable::size() const {
    return numelems ;
}

bool RobinHoodHashTable::isEmpty() const {
    if (numelems == 0){
        return true ;
    }
    else {
        return false ;
    }
}

bool RobinHoodHashTable::insert(const string&amp; elem) {
    //获取index
    int elemhashValue = hashFn(elem) ;
    int index = elemhashValue % capasity ;

    //记录插入组
    Slot *totakein =nullptr ;
    totakein = new Slot[1] ;
    totakein-&gt;distance = 0;
    totakein-&gt;value = elem;

    //判含
    Slot* cur = &amp;elems[index];
    int indexcopy = index ;
    int step = 0 ;
    while (cur-&gt;distance &gt;= 0) {
        if (step &gt; cur-&gt;distance){
            break ;
        }
        if (cur-&gt;value == elem) {
            delete[] totakein ;
            return false ;
        }
        //环型数组
        index = (index + 1) % capasity;
        //跑一圈
        if (index == indexcopy){
            break ;
        }
        cur = &amp;elems[index];
        step++;
    }
    //重置index
    index = indexcopy ;
    cur = &amp;elems[index];
    //开始插入
    while(totakein-&gt;distance &gt;= 0){
        //如果满了就pruning
        if (RobinHoodHashTable::numelems == capasity){
            delete []totakein ;
            return false ;
        }
        //如果满足Robin
        if (totakein-&gt;distance &gt; cur-&gt;distance){
            swap(cur-&gt;distance,totakein-&gt;distance);
            swap(cur-&gt;value,totakein-&gt;value);
            totakein-&gt;distance++;
        }else {
            totakein-&gt;distance++;
        }
        //环形数组
        index = (index+1) % capasity ;
        cur = &amp; elems[index] ;
    }
    //插入成功
    numelems++;
    delete[]totakein ;
    return true ;
}

bool RobinHoodHashTable::contains(const string&amp; elem) const {
    //获取初值
    int elemhashValue = hashFn(elem) ;
    int index = elemhashValue % capasity ;
    Slot* cur = &amp;elems[index] ;
    
    int indexcopy = index ;
    int step = 0 ;
    //判含
    while (cur-&gt;distance &gt;= 0) {
        //Robin法则
        if (step &gt; cur-&gt;distance){
            return false ;
        }
        if (cur-&gt;value == elem) {
            return true ;
        }
        //环形数组
        index = (index + 1) % capasity;
        if (index == indexcopy){
            return false ;
        }
        cur = &amp;elems[index];
        step++;
    }
    return false ;
}

bool RobinHoodHashTable::remove(const string&amp; elem) {
    //获取初值
    int elemhashValue = hashFn(elem) ;
    int index = elemhashValue % capasity ;
    Slot* cur = &amp;elems[index] ;
    int step = 0;

    // 找到位置,用contain更加方便,但是回重复计算hash
    int indexcopy = index ;
    while (cur-&gt;distance &gt;= 0) {
        if (step &gt; cur-&gt;distance){
            return false ;
        }
        if (cur-&gt;value == elem) {
            goto label ;
        }
        index = (index + 1) % capasity;
        if (index == indexcopy){
            return false ;
        }
        cur = &amp;elems[index];
        step++;
    }
    return false ;

    label:
    // 已经找到正确的 cur
    Slot* prev = cur;
    index = (index + 1) % capasity;
    cur = &amp;elems[index];

    while (true) {
        if (cur-&gt;distance &lt;= 0) {
            prev-&gt;distance = EMPTY_SLOT;
            break;
        }
        //shift-back delete
        prev-&gt;distance = cur-&gt;distance - 1;
        prev-&gt;value = cur-&gt;value;

        // 更新 prev 和 index
        prev = cur;
        index = (index + 1) % capasity;
        cur = &amp;elems[index];
    }
    //成功删除
    numelems--;
    return true;
}
</code></pre>
<ul>
<li>环形数组</li>
<li>Robin设计</li>
<li>复现能力</li>
</ul>
<h3>CRUD for links</h3>
<p><strong>lookup in links</strong></p>
<pre><code class="language-cpp">Nucleotide* findFirst(Nucleotide* dna, Nucleotide* target) {
    if (target == nullptr) {
        return dna;
    }
    Nucleotide* headt = target;
    while (dna != nullptr) {
        if (dna-&gt;value == headt-&gt;value) {
            Nucleotide* ans = dna;
            Nucleotide* tempDna = dna;
            Nucleotide* tempTarget = target;
            while (tempTarget != nullptr &amp;&amp; tempDna != nullptr) {
                if (tempDna-&gt;value != tempTarget-&gt;value) {
                    break;
                }
                tempDna = tempDna-&gt;next;
                tempTarget = tempTarget-&gt;next;
            }
            if (tempTarget == nullptr) {
                return ans;
            }
        }
        dna = dna-&gt;next;
    }
    return nullptr;
}
</code></pre>
<p><strong>change in links</strong></p>
<pre><code class="language-cpp">bool spliceFirst(Nucleotide*&amp; dna, Nucleotide* target) {
    if (target == nullptr) {
        return true;
    }

    Nucleotide* match = findFirst(dna, target);
    if (match == nullptr) {
        return false;
    }

    Nucleotide* prev = nullptr;
    Nucleotide* current = dna;
    while (current != match) {
        prev = current;
        current = current-&gt;next;
    }

    Nucleotide* tempTarget = target;
    //双切操作,一个prev,一个cur,prev标记一个断口,cur移动到另一个,删完了以后两个链接
    while (tempTarget != nullptr &amp;&amp; current != nullptr) {
        //cur待删除
        Nucleotide* toDelete = current;
        //cur指向下一个了
        current = current-&gt;next;
        tempTarget = tempTarget-&gt;next;
        delete toDelete;
    }
    //布线
    if (prev == nullptr) {
        if (current == nullptr){
            dna = nullptr ;
        }else {
            dna = current ;
            dna-&gt;prev = prev;
        }
    } else {
        if (current == nullptr){
            prev-&gt;next = current ;
        }else {
            prev-&gt;next = current ;
            current-&gt;prev = prev ;
        }
    }
    return true;
}
</code></pre>
<h3>graph algorithms</h3>
<ul>
<li>dijkstra </li>
<li>A*:heuristic</li>
</ul>
<h2>第六单元-multiple threads and parallel computing</h2>
<h3>threads</h3>
<blockquote>
<p>Although we normally think of a process as having a single control flow, in modern systems a process can actually consist of multiple execution units, called threads, each running in the context of the process and sharing the same code and global data. Threads are an increasingly important programming model because of the requirement for concurrency in network servers, because it is easier to share data between multiple threads than between multiple processes, and because threads are typically more efficient than processes. Multi-threading is also one way to make programs run faster when multiple processors are available...</p>
</blockquote>
<p>A thread is based on a function, we use multiple threads to solve CPU intensive problems.</p>
<hr>
<p><strong>end</strong>
<img src="../graph_bed/cs106b_end1.png" alt="cs106b_end">
<img src="../graph_bed/cs106b_end2.png" alt="cs106b_end2">
<img src="../graph_bed/cs106b_end3.png" alt="cs106b_end3"></p>
<blockquote>
<p>CS is more than just programming, these skills will make you better at whatever you choose to do in life.</p>
</blockquote>
</div>
      <div class="footer border-top border-gray-light mt-5 pt-3 text-right text-gray">
        This site is open source. <a href="https://github.com/daoshi1593/daoshi1593.github.io/edit/main/md-files/cs106b_ALL.md">Improve this page</a>.
      </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const toc = document.getElementById("toc");
        const ul = document.createElement("ul");
        toc.appendChild(ul);
        const headings = document.querySelectorAll("h1, h2, h3");
        let currentLevel = 1;
        let currentUl = ul;

        headings.forEach((heading, index) => {
          const level = parseInt(heading.tagName.substring(1), 10);
          const item = document.createElement("li");
          const link = document.createElement("a");
          const id = `heading-${index}`;

          heading.id = id;
          link.href = `#${id}`;
          link.textContent = heading.textContent;
          item.appendChild(link);

          while (level > currentLevel) {
            const newUl = document.createElement("ul");
            if (!currentUl.lastElementChild) {
              currentUl.appendChild(document.createElement("li"));
            }
            currentUl.lastElementChild.appendChild(newUl);
            currentUl = newUl;
            currentLevel++;
          }
          while (level < currentLevel && currentUl.parentNode !== toc) {
            currentUl = currentUl.parentNode.closest("ul");
            currentLevel--;
          }

          if (level === currentLevel) {
            currentUl.appendChild(item);
          }
        });
      });
    </script>
  </body>
</html>
      